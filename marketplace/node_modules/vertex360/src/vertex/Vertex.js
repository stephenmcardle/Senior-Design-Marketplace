const formatCallback = require('./callback')
const Router = require('./Router')
// const fs = require('fs')

class Vertex {
	constructor(){
		this.routes = []
		this.staticDir = null
		// this.paths = {}
	}

	expressVersion(app){ // app is an express app
		var _this = this
		app.use('/turbo', function(req, res, next){
			res.json({
				confirmation: 'success',
				data: JSON.stringify(_this.routes)
			})
		})

		_this.routes.forEach((route) => {
			app.use(route.stem, (req, res, next) => {
				res.json({
					confirmation: 'success',
					data: route.stem
				})
			})
		})

		return app
	}

	useStatic(directory){
		this.staticDir = directory
	}

	use(path, routeHandler){
		// routeHandler.stem = path
		routeHandler.setStem(path)
		this.routes.push(routeHandler)
	}

	get(path, requestHandler){ // direct path, no route handler passed in:
		var routeHandler = new Router()
		routeHandler.setStem('/') // default stem to '/'
		routeHandler.get(path, requestHandler)
		this.routes.push(routeHandler)
	}

	post(path, requestHandler){ // direct path, no route handler passed in:
		var routeHandler = new Router()
		routeHandler.setStem('/') // default stem to '/'
		routeHandler.post(path, requestHandler)
		this.routes.push(routeHandler)
	}

	// TDOD: these do not exist yet on the Router.js class. Have to implement:
	// put(path, requestHandler){ // direct path, no route handler passed in:
	// 	var routeHandler = new Router()
	// 	routeHandler.setStem('/') // default stem to '/'
	// 	routeHandler.put(path, requestHandler)
	// 	this.routes.push(routeHandler)
	// }

	// delete(path, requestHandler){ // direct path, no route handler passed in:
	// 	var routeHandler = new Router()
	// 	routeHandler.setStem('/') // default stem to '/'
	// 	routeHandler.delete(path, requestHandler)
	// 	this.routes.push(routeHandler)
	// }

	routeNotFound(event, msg){
		const method = event.httpMethod.toLowerCase() // get, post, put, delete
		var data = {
			isBase64Encoded: false,
			statusCode: 501,
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify({
				confirmation: 'fail',
				message: msg
			})
		}

		return data
	}

	// this is the main entry point of the app - it is called by the actual AWS Lambda entry:
	handle(lambda_config){ // {event: event, context: context, callback: callback}
		const event = lambda_config.event
		const callback = lambda_config.callback

		const method = event.httpMethod.toLowerCase() // get, post, put, delete

		if (method == 'post'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handlePost(event) != null){
					pkg = pathRouter.handlePost(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			const formatted = formatCallback(event, callback, pkg.routeParams)
			pkg.routeHandler(formatted.req, formatted.res)
			return
		}

		if (method == 'put'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handlePut(event) != null){
					pkg = pathRouter.handlePut(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			const formatted = formatCallback(event, callback, pkg.routeParams)
			pkg.routeHandler(formatted.req, formatted.res)
			return
		}

		if (method == 'delete'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handleDelete(event) != null){
					pkg = pathRouter.handleDelete(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			const formatted = formatCallback(event, callback, pkg.routeParams)
			pkg.routeHandler(formatted.req, formatted.res)
			return
		}

		if (method == 'get'){
			if (event.path.indexOf('.') == -1){
				let pkg = null
				for (let i=0; i<this.routes.length; i++){
					let pathRouter = this.routes[i]
					if (pathRouter.handleGet(event) != null){
						pkg = pathRouter.handleGet(event)
						break
					}
				}

				if (pkg == null){
					callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
					return
				}

				const formatted = formatCallback(event, callback, pkg.routeParams)
				pkg.routeHandler(formatted.req, formatted.res)
				return
			}

			// this is a static file, redirect to CDN:
			if (event.headers==undefined || event.headers==null){
				callback(null, {
					isBase64Encoded: false,
					statusCode: 500,
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({
						confirmation: 'fail',
						data: 'Missing Turbo-Vertex-App header (headers is null)'
					})
				})

				return
			}

			const slug = event.headers['Turbo-Vertex-App']
			if (slug == null){
				callback(null, {
					isBase64Encoded: false,
					statusCode: 500,
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({
						confirmation: 'fail',
						data: 'Missing Turbo-Vertex-App header'
					})
				})

				return
			}

			// USE CDN for static assets, e.g. - https://cdn.turbo360-vertex.com/dkwon-vertex-oienuk/public/images/pip.png
			const dir = this.staticDir || 'public' // default to public directory
			const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
			const url = concat.replace('//', '/') // this will happen if there is no static directory specified

			// redirect to CDN:
			callback(null, {
				isBase64Encoded: false,
				statusCode: 301,
				headers: {'Location': 'https://'+url},
				body: ''
			})
		}
	}
}

module.exports = Vertex